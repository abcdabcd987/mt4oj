%# -*- coding: utf-8-unix -*-

\chapter{Background}
\label{chap:background}

\section{Online Judge}
    
    \subsection{Programming Education}

        As we walk into a century surrounded by all kinds of computing devices,
        programming skill gains more and more attention.  % TODO: cite
        Universities used to teaching programming to merely computer science majored students,
        but more and more of them are opening the course to all.  % TODO: cite

        One part of programming education is mastering one programming language.
        Mechanisms of modern computers may be too complicated for non computer science majored students to learn,
        but thanks to the abstractions of processors, operating systems, and high-level programming languages,
        it becomes easier and easier to program computers to do what users want.
        The most popular high-level programming languages includes C++, Python, Java, and so on. % TODO: cite
        Instead of dealing with registers and memory addresses using processors' instruction set,
        high-level programming languages bring up concepts like variables, arrays, expressions, loops, functions,
        threads, processes, and other computer science abstractions.

        The other part of programming education is learning programmatic thinking, in other words,
        algorithms and data structures, especially for computer science majored students.
        There may be several solutions to the same problem, but taking different approaches costs differently.
        An $O(n\log n)$ algorithm better scales to a larger input comparing to an $O(n^2)$ algorithm.
        Programming also helps students cultivate thinking skills.
        There are mind sports specially focus on algorithms.
        For instance, ACM International Collegiate Programming Contest (\emph{ACM-ICPC}) is an annual
        competitive programming competition among the universities of world.
        In 2017, 49,935 students from 3,098 universities in 111 countries participated. % TODO: cite (wiki)
        Companies value this kind of thinking skills, as well.
        It is a common practice for companies to ask algorithm puzzles when interviewing candidate programmers.

        Higher level coursers in computer science, like Networking, Machine Learning, and so on,
        need students to be able to express their mind in code.
        Therefore, It is crucial for students to master programming at the very beginning of study,
        which puts challenges to entry-level courses, such as Programming Language, Data Structures, and so on.

        Like any other skills, both mastering one programming language and learning programmatic thinking
        require students to practice repeatedly.
        Important ways of these entry-level courses to help students master programming are assignments and exams.
        Problems in the assignments and exams are likely to be tasks asking students to write code.
        Graphics interfaces, keyboard and mouse inputs, video and audio outputs, networking connections,
        reading from and writing to disks, and so on, are common operations what programs in end-users' computers would have,
        but it would be too much burden for starters.
        Because these problems are for educational purpose only, the tasks are simplified from the real world ones.

        Descriptions of these problems are simple and neat. The tasks are idealized.
        Students do not need to deal with neither incorrect inputs nor malicious data.
        Problems are algorithmic in nature, thus there is no need to consider human-computer interaction.
        Memory is assumed to be large enough for the problems, therefore students can avoid disk operations
        and keep everything in memory.
        In a word, these assignments and exams ask students to write code that focus on the ``computing'' part of programming.

        After students finish the tasks, there need to be some ways to give them feedback, at least,
        tell students whether their solution is correct or not.
        Traditionally, grading programming solutions had no difference from grading calculus homework.
        And the emerge of online judges two decades ago enabled more efficient grading.
        
    \subsection{Manual Grading}

        Before the appearance of online judges, teachers needed to grade programming solutions manually.
        First, students handed in their solutions.
        Then, graders (either the professor himself/herself or the teaching assistants)
        would read the code and give marks based on their professional judgment.
        Manual grading is still a common practice nowadays in other subjects, such as mathematics and physics.
        Though widely used, its effectiveness is still affected by several non-controllable factors
        and has significant drawbacks. \cite{Kurnia2001}

        \subsubsection{Discouragement of Alternative Solutions}

            When the teachers are sketching a problem, they have a standard solution in mind.
            So when graders are grading students' solutions, they expect the code to be similar to
            the standard solution that they were told.
            However, it is likely that there are several alternative solutions to the same problem
            with the same complexity if not better.
            For instance, suppose an assignment can reduce to a minimum spanning tree problem
            and the author expects the Prim algorithm.  % TODO: cite Prim
            A student might turn in a solution with Kruskral algorithm which is also an algorithm that
            solves the minimum spanning tree problem.  % TODO: cite Kruskral
            In this case, if the grader is not aware of Kruskral algorithm, the grader might give a wrong verdict
            because Kruskral algorithm looks completely different from Prim algorithm, i.e. the standard solution.
            Notice that this is not the fault of the grader, because the grader might be a teaching assistant
            who is only expected to be familiar with the standard solution.
            Neither is this the fault of the problem author, because there can be any number of alternative solutions
            and the author cannot enumerate them all.
            Nor should we blame the student.
            In the contrary, students with alternative solutions should be encouraged.

        \subsubsection{Slow Grading}

            Grading a programming solution can takes a long time.
            Unlike a solution to mathematics homework in which students will explain their thinking process
            step by step in natural language,
            a solution to programming problem is code in some programming language which is designed
            for machines to compile, instead of letting humans to read.
            The grader have to read the code carefully in order to understand the solution.
            Then they need to look into details trying to find potential mistakes.
            Consequently, the grading process can be very slow.

        \subsubsection{Inconsistency}

            The same solution might have different scores if it is graded by different graders.
            For example, some graders know more than the standard solutions,
            and thus justify the alternative solutions.

            Even for the same grader to check the same solution at different times might lead to different results.
            For instance, at the beginning of grading, the grader might be very patient
            and carefully reason about each line of code.
            However, after hours of grading, the grader could feel tired and distracted
            and might want to finish grading as soon as possible.
            In this case, the grader might only check if the solution matches some patterns of the standard solution.

            Needless to say, the same solution is likely to have completely different verdicts
            depending on who the grader is and what status he or she is in.

        \subsubsection{Ignorance of Details Mistakes}

            Because of understanding students' solution costs graders lots of energy,
            subtle mistakes hidden in details often escape from being found.
            For example, supposing the standard solution is Floyd algorithm, % TODO: cite
            the grader might expect students' solutions to have two kinds of patterns:
            three nested loops and a dynamic programming equation.
            However, the solution might mixing up the permutation of the three loop variables,
            which makes the algorithm no longer correct.
            The grader might not be able to find such subtle an error.
            % TODO: correct & incorrect floyd code

        \subsubsection{Low Scalability}

            One of the hot topics computer scientists deals with is scalability.
            Ironically, manually grading programming assignments doesn't scale well.
            The increasing in either students or problems significantly add burden to graders.
            Apparently the total number of problems the professor can assign is proportional to
            the number of teaching assistants, and is inversely proportional to the number of students.
            Although the department could employ more teaching assistants to avoid the intolerable grading time,
            the inconsistency caused by different graders would become more and more disturbing.

        \subsubsection{Long Feedback Time}

            Manual grading takes graders a long time to justify the correctness of students' solutions,
            in the mean time, the feedback time of students is even longer.
            Counting the time starting from the moment a student finishes the solution to the moment
            the student knows about the verdict, it usually takes days if not weeks to have the feedback.
            Days after writing the code, the student might need to spend extra time to recover
            the thinking process when he or she was solving the problem.
            Sometimes, students just fail to go back to the mindset then, and thus the lessons learned from
            the assignment mistakes would be discounted.

    \subsection{Automatic Grading}

        The invention of online judges brought the idea of automatic grading, that is,
        letting a computer program to determine the correctness of programming assignments.
        In order to transit from manual grading to automatic grading,
        teachers need to formalize the grading process in a way that a program grader are easy to handle,
        otherwise computer scientists need to build a strong artificial intelligence
        just to grade some homework and exams, which is not yet possible for now and wastes its talent.

        \subsubsection{Grading Process}

            Instead of writing code on pieces of paper, students need to write code on a computer
            and hand in the source code as it is to the online judge.
            In fact, submitting the source code makes more sense than handing in pieces of paper.
            Students can avoid compilation errors by compiling the source code,
            which would be a trivial mistake but often caught in hand-written code.
            Further more, students can convenience themselves the code is correct by running the code
            over several inputs and they can even debug it if they find something not working as expected.

            To simplify programming tasks, avoiding fancy human-computer interaction
            and complicated input/output operations, online judges require the problem author and students
            to behave within some conventions:

            \begin{itemize}
                \item The solution code should compile and run (or can be interpreted for interpreted languages).
                \item The program should read data from the \emph{standard input}
                      and write answers to the \emph{standard output}.
                \item The program should not have any other input/output operations, such as writing a file,
                      connecting to the network, and so on.
                \item The program should terminate within certain \emph{time limit} and \emph{memory limit}.
                \item The program should not have any malicious behaviors.
                \item The problem author should specify the \emph{input format} and the \emph{output format}.
                \item The problem author should specify \emph{the range of input data}.
                \item The problem author should specify the time limit and memory limit.
                \item The problem author should make several \emph{testcases} along with the problem.
                      Each testcase consist of input data and output data.
                      Output data is the answer as if produced by a correct program.
                      The input and output data should be consistent with the input and output format
                      specified in the problem description.
            \end{itemize}

            The problem author can give several sample testcases in the problem description
            to help students understand the problem setting and the input/output format.
            Students can also use it to verify if there is obvious flaw in the solution.
            However, there should be a set of secret testcases that students cannot access.
            Otherwise, the students merely need to write a program that prints the corresponding
            standard answer according to the input.

            Students' solution presumes to be correct if it can pass all testcases.
            If the program passes only part of the testcases, the online judge can also gives partial credits.
            With this convention in mind, the grading process becomes programmatic.

            \begin{enumerate}
                \item Students submit the source code to the online judge.
                \item The online judge compiles the source code (if it is a compiled language).
                \item The online judge runs the program with the input the problem author designed.
                \item The online judge checks if the program terminates within the specified
                      time and memory constraints and does not have any malicious behaviors.
                \item The online judge compares the program output to the corresponding output
                      the problem author designed.
                \item The above three steps repeats until all of the testcases have been examined.
                \item The online judge either claims the solution to be correct if the program
                      has passed all testcases or gives partial credits.
            \end{enumerate}

            A flawed solution might be able to pass one or two testcases, but the chance of
            passing all testcases is low enough if the testcases was carefully designed.

            This kind of automatic grading process can also detect incorrect algorithmic complexity.
            For example, it is easy for an $O(n\log n)$ solution to terminate within one second
            on a $n=10,000$ input, but not likely for an $O(n^3)$ one.
            The same idea applies to space complexity due to the memory limit
            specified in the problem description.

        \subsubsection{Advantages}

            The automatic grading process addresses the flaws in manual grading.

            By definition of correctness, any solution that solves a problem correctly
            is able to pass all the testcases.

            Automatic grading is at least dozens of times faster than manual grading.
            Assuming the time limit for each testcase is one second and there are ten testcases in total,
            the maximum run time for a student's solution would be ten seconds.
            There are some extra times costs by the automatic grader, including
            compiling the student's solution, comparing the program output to the standard answer,
            and some other necessary operations of the automatic grader.
            Therefore, in the worst case,
            the grading process can be done in a little bit more than ten seconds in total.
            Typically, the whole process should finish in seconds,
            since a correct solution is expected to run significantly faster than the time limit.

            With such fast grading speed, students can get the feedback almost instantly.
            Hence, they are quite clear about the code they wrote just now, and thus easier to 
            reason about the mistakes if the online judge did not give them full credits.

            Notice that the automatic grading process does not require
            the teacher or any teaching assistants presenting
            once the problem author has published the problem.
            The interaction only happens between students and the online judge.
            Without human being involving in the grading process,
            lots of uncertainties are eliminated,
            because the execution of the grading program is determined.
            As long as the machine running the automatic grader has sufficient computing power,
            the running result will be the same.
            The maintainer of the online judge simply need to
            make sure the computer is dedicated for automatic grading.
            The automatic grading program would not have any `mood', nor does it feel tired.
            Consequently, it will produce consistent verdicts.

            Clearly, the increase in the number of students and problems does not add burdens to the online judge.
            It just reduces the idle time of the automatic grader.
            At the worst case, new submissions start to accumulate and waits in queue.
            In this case, simply buying more machines and running more automatic graders
            suffice to keep a short enough waiting time.
            The costs of new computers is cheaper than paying stipend to teaching assistants,
            not to mention that lots of departments have spare servers to use.

    \subsection{Online Judges}

        Due to its overwhelming superiority, universities widely
        integrate online judges with programming-related courses.
        There are dozens of popular online judges.
        Some of them are famous world-wide, such as CodeForces, TopCoder, SPOJ, uVA, and so on. % TODO: cite
        Online judges can roughly divide into three categories.

        One is maintained by universities, such as POJ, HDU, and so on. % TODO: cite
        The university's ACM-ICPC participants actively train on these online judges.
        In addition, these online judges also serve programming courses.
        Teaching assistants hand out homework assignments and organize exams on online judges.

        Another is maintained by high schools
        or retired Olympiad in Informatics (\emph{OI}) participants,
        such as LibreOJ, and so on. % TODO: cite
        Because most high schools do not teach programming systematically,
        the only purpose of these kind of online judges is their internal OI training.

        The last category is operated by commercial companies. % TODO: cite; TODO: marong's OJ
        LeetCode, for example, focus on the interview problems ask by big companies.
        Users need to pay for the full problem set and solutions with high quality explanations.
        In China, the market of private tutoring on competitive programming competitions is getting larger.
        Some commercial companies build online judges, compose series of problems, organize contests,
        and teach lessons for their paid customers.

        Interestingly, almost all online judges share the same convention mentioned in previous subsection.
        Different online judges have their own characteristics as well.

        \subsubsection{Design of Online Judges}

            Online judges usually have a web interface.
            The advantage of using a web interface over native graphics interface is that
            it can easily support different platform.
            Unlike traditional applications, each operating system has a large share of users of online judges.
            This might be because Windows, Linux, and macOS are all very popular among programmers.
            In addition, some of competitive programming competitions encourages the usage of Linux,
            such as Chinese National Olympiad in Informatics (\emph{NOI}).  % site: NOI Linux article
            Since all operating systems have web browsers,
            users do not need to install extra software to use the online judge.
            Some active participants of ACM-ICPC or OI even use mobile web browsers on their smart phones
            to read problems on online judges and think about them in their spare time.

            Users need to register an account on the online judge before they can submit their solution to it.
            Since each solution is tied to an account, online judges can easily show statistics,
            like which problems the user have solved, which problems the user has tried but not ye solved.
            Users can design their own training schedule according to these statistics.
            It also enables computer scientists to create models for users and
            then uses artificial intelligence to design the training schedule for users.

            Once users submit a solution through the web interface,
            the online judge keeps the submission in the database,
            and assign an automatic grader to grade the solution.
            The result of an submission usually can be the following ones:

            \begin{description}
                \item[Accepted] The submitted code has passed all the testcases.
                \item[Partial Credit] The submitted code has passed part of the testcases.
                \item[Compilation Error] The submitted code has failed to compile.
                \item[Wrong Answer] The submitted code has produced incorrect answer on some testcases.
                \item[Runtime Error] The submitted code has exited with non-zero exitcode unexpectedly
                                     when running some testcases.
                \item[Time Limit Exceeded] The submitted code has not terminated within the specified time limit
                                           when running some testcases.
                \item[Memory Limit Exceeded] The submitted code has tried to allocate more memory than the
                                             specified memory limit when running some testcases.
            \end{description}

            In addition to the result, online judges also display two important factors:
            the total running time and the maximum memory usage,
            which indicates the performance of a solution.

            Online judges can run multiple automatic graders on several machines or
            on a machine with multiple processor cores.
            Previous subsection has described the how a automatic grader works.

            The code automatic graders compile and run is submitted by users from the Internet
            which is untrusted and can even be malicious.
            Therefore, the design of online judges must include serious security concerns.

        \subsubsection{Virtual Judge}

        \subsubsection{Encouragement in Students' Proactive Participation}


\section{Machine Teaching}

\section{Logistic Regression}

\section{Factorization Machine}

\section{Boosting Tree}

\section{Recurrent Neural Network}

\section{Reinforcement Learning}

    \subsection{Asynchronous Advantage Actor Critic}
